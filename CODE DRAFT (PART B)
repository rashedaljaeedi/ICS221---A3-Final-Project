import math
import heapq
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

class roadmapGraph:
    def __init__(self):
        self.G = nx.Graph()
        self.node_labels = {
    "SZR": "Sheikh Zayed Road",
    "JBR": "Jumeirah Beach Road",
    "AWl": "Al Wasl Road",
    "ER": "Emirates Road",
    "AKR": "Al Khail Road",
    "DMW": "Dubai Marina Walk",
    "AMR": "Al Maktoum Road",
    "MBRB": "Mohammed Bin Rashid Boulevard",
    "DC": "Dubai Creek",
    "ARR": "Al Rigga Road",
    "AAR": "Al Ain Road",
    "AQR": "Al Qudra Road",
    "HS": "Hessa Street",
    "SMbZR": "Sheikh Mohammed bin Zayed Road",
    "ASR": "Al Sufouh Road",
    "ADS": "Al Diyafa Street",
    "USR": "Umm Suqeim Road",
    "ABR": "Al Barsha Road",
    "AFS": "Al Furjan Street",
    "H1": "HOUSE 1",
    "H2": "HOUSE 2",
    "H3": "HOUSE 3"
}


        self.house_data = [
            {"id": "H1", "location": "SZR"},
            {"id": "H2", "location": "JBR"},
            {"id": "H3", "location": "AWl"},
            # Add more house data as needed
        ]

        # Add nodes to the graph
        for node_id, label in self.node_labels.items():
            self.G.add_node(node_id, label=label)

        # Add houses as nodes to the graph
        for house in self.house_data:
            self.G.add_node(house["id"], label="House", location=house["location"])

        # Add edges to the graph
        edges_with_weights = [
    ("SZR", "JBR", {"weight": 3, "id": "R1"}),
    ("JBR", "AWl", {"weight": 3, "id": "R2"}),
    ("AWl", "SZR", {"weight": 3, "id": "R3"}),
    ("ER", "AKR", {"weight": 5, "id": "R4"}),
    # Other edges follow the same structure...
    ("SZR", "DMW", {"weight": 1, "id": "R19"}),  # Assuming "BN" is the intended node instead of "ll"
    ("DMW", "AAR", {"weight": 3, "id": "R20"}),
    ("AFS", "HS", {"weight": 8, "id": "R21"}),
    ("MBRB", "HS", {"weight": 1, "id": "R22"}),
    ("MBRB", "ER", {"weight": 1, "id": "R23"}),
    ("USR", "AAR", {"weight": 2, "id": "R24"}),
    ("ADS", "ARR", {"weight": 2, "id": "R25"}),
    ("ABR", "AAR", {"weight": 5, "id": "R26"}),
    ("ABR", "AQR", {"weight": 4, "id": "R27"}),
    ("AFS", "AQR", {"weight": 2, "id": "R28"}),
    ("AMR", "AQR", {"weight": 2, "id": "R29"}),
    ("SZR", "AQR", {"weight": 6, "id": "R30"}),
    ("AMR", "AAR", {"weight": 4, "id": "R31"}),
    ("AMR", "AWl", {"weight": 2, "id": "R32"}),
    ("DMW", "JBR", {"weight": 3, "id": "R33"}),
    ("DMW", "AWl", {"weight": 3, "id": "R34"}),
    ("AKR", "ARR", {"weight": 4, "id": "R35"}),
    ("DMW", "ARR", {"weight": 4, "id": "R36"}),
    ("AKR", "JBR", {"weight": 3, "id": "R37"}),
    ("AKR", "SZR", {"weight": 4, "id": "R38"}),
    ("AKR", "AFS", {"weight": 7, "id": "R39"}),
    ("SMbZR", "DC", {"weight": 3, "id": "R40"}),
    ("SMbZR", "AKR", {"weight": 4, "id": "R41"}),
    ("SMbZR", "SZR", {"weight": 8, "id": "R42"}),
    ("ASR", "DC", {"weight": 4, "id": "R43"}),
    ("ASR", "ARR", {"weight": 5, "id": "R44"}),
]
        for start, end, edge_data in edges_with_weights:
            if start in self.node_labels and end in self.node_labels:
                self.G.add_edge(start, end, weight=edge_data['weight'])
            else:
                print(f"Edge from {start} to {end} cannot be added as one of the nodes does not exist.")

    def dijkstra(self, start_vertex):
        distances = {vertex: math.inf for vertex in self.G.nodes}
        distances[start_vertex] = 0
        pq = [(0, start_vertex)]
        came_from = {vertex: None for vertex in self.G.nodes}  # To keep track of the path
        while pq:
            current_distance, current_vertex = heapq.heappop(pq)
            for neighbor, edge_data in self.G[current_vertex].items():
                neighbor_vertex = neighbor
                weight = edge_data['weight']
                distance = current_distance + weight
                if distance < distances[neighbor_vertex]:
                    distances[neighbor_vertex] = distance
                    came_from[neighbor_vertex] = current_vertex  # Update the path
                    heapq.heappush(pq, (distance, neighbor_vertex))
        # Build the shortest paths from start_vertex to all other vertices
        shortest_paths = {vertex: [] for vertex in self.G.nodes}
        for vertex in self.G.nodes:
            if distances[vertex] != math.inf:
                current_vertex = vertex
                while current_vertex is not None:
                    shortest_paths[vertex].insert(0, current_vertex)
                    current_vertex = came_from[current_vertex]
        return distances, shortest_paths
    def heuristic(self, current_vertex, end_vertex):
    # Get the weights of all outgoing edges from the current vertex
        weights = [edge_data['weight'] for neighbor, edge_data in self.G[current_vertex].items()]
    # If there are no outgoing edges, return infinity
        if not weights:
          return math.inf
    # Otherwise, return the minimum weight
        return min(weights)


    def a_star(self, start_vertex, end_vertex):
        distances = {vertex: math.inf for vertex in self.G.nodes}
        distances[start_vertex] = 0
        open_set = [(0, start_vertex)]
        came_from = {vertex: None for vertex in self.G.nodes}
        while open_set:
          current_distance, current_vertex = heapq.heappop(open_set)
          if current_vertex == end_vertex:
              path = []
              while current_vertex:
                path.append(current_vertex)
                current_vertex = came_from[current_vertex]
            # Print the shortest path from the start vertex to the end vertex
              print(f"Shortest path from {start_vertex} to {end_vertex}: {' -> '.join(path[::-1])}")
              return path[::-1]
          for neighbor, edge_data in self.G[current_vertex].items():
              neighbor_vertex = neighbor
              weight = edge_data['weight']
              tentative_g_score = distances[current_vertex] + weight
              if tentative_g_score < distances[neighbor_vertex]:
                  came_from[neighbor_vertex] = current_vertex
                  distances[neighbor_vertex] = tentative_g_score
                  f_score = tentative_g_score + self.heuristic(neighbor_vertex, end_vertex)
                  heapq.heappush(open_set, (f_score, neighbor_vertex))
        print("Path is not found")
        return "Path is not found"

    def find_shortest_path_to_house(self, house_id, destination_vertex):
        house = next((house for house in self.house_data if house["id"] == house_id), None)
        if house is None:
            print(f"House {house_id} not found.")
            return f"House {house_id} not found."

        house_name = self.node_labels.get(house["location"], "Unknown")
        start_vertex = house["location"]
        shortest_path = self.dijkstra(start_vertex)
        shortest_paths = shortest_path[1]  # Get the shortest paths dictionary
        shortest_distance = shortest_paths.get(destination_vertex, f"Destination {destination_vertex} not reachable from {house_name}.")
      # Print the shortest path from the house to the destination vertex
        print(f"Shortest path from house {house_id} ({house_name}) to {destination_vertex}: {shortest_distance}")
        return shortest_distance




    def plot_graph(self):
        plt.figure(figsize=(18, 18))

        # Define levels for the nodes to organize them into concentric circles
        levels = {
            1: ["SZR", "JBR", "AWl"],
            2: ["ER", "AKR", "DMW", "AMR"],
            3: ["MBRB", "DC", "ARR", "AAR", "AQR"],
            4: ["HS", "SMbZR", "ASR", "ADS", "USR", "ABR", "AFS"],
        }

        # Initialize a dictionary to hold the position of each node
        pos = {}
        # Set the center point for the circles
        center = np.array([0.5, 0.5])

        # Add positions for the houses
        pos["H1"] = (0.8, 0.2)
        pos["H2"] = (0.3, 0.8)
        pos["H3"] = (0.5, 0.5)

        # Define a spacing value to determine the distance between circles
        radius_increment = 0.3

        # Calculate the position for each node based on its level
        for level, nodes in levels.items():
            circle_radius = level * radius_increment
            angle_increment = 2 * np.pi / len(nodes)
            for i, node in enumerate(nodes):
                angle = i * angle_increment
                x = center[0] + circle_radius * np.cos(angle)
                y = center[1] + circle_radius * np.sin(angle)
                pos[node] = (x, y)

        # Draw nodes using the positions and colors defined
        for level, nodes in levels.items():
            nx.draw_networkx_nodes(self.G, pos, nodelist=nodes, node_size=700, node_color='lightblue', alpha=0.9)

        # Draw houses with a different color
        house_nodes = [node for node in self.G.nodes if "label" in self.G.nodes[node] and self.G.nodes[node]["label"] == "House"]
        nx.draw_networkx_nodes(self.G, pos, nodelist=house_nodes, node_size=500, node_color='lightgreen', alpha=0.9)
        # Draw node labels
        nx.draw_networkx_labels(self.G, pos, labels=self.node_labels, font_size=12)

        # Draw edges with specified colors and labels for weights
        nx.draw_networkx_edges(self.G, pos, edge_color='gray')
        # Place this right after drawing the edges
        nx.draw_networkx_edge_labels(self.G, pos, edge_labels=nx.get_edge_attributes(self.G, 'weight'), font_color='red')

        # Customizing edge labels to include only weight in red and smaller font size
        edge_labels = nx.get_edge_attributes(self.G, 'weight')
        for edge, label in edge_labels.items():
            x = (pos[edge[0]][0] + pos[edge[1]][0]) / 2
            y = (pos[edge[0]][1] + pos[edge[1]][1]) / 2
            angle = np.arctan2(pos[edge[1]][1] - pos[edge[0]][1], pos[edge[1]][0] - pos[edge[0]][0])

        # Remove axis for a cleaner look
        plt.axis('off')

        # Display the plot
        plt.show()

# Instantiate the roadmapGraph object
roadmap_graph = roadmapGraph()

# Plot the graph
roadmap_graph.plot_graph()

# Test case 1: Dijkstra's algorithm
start_vertex = "SMbZR"
end_vertex = "USR"
print("\nTest case 1: Dijkstra's algorithm")
shortest_distances, shortest_paths = roadmap_graph.dijkstra(start_vertex)
print(f"Shortest distance from {start_vertex} to {end_vertex}: {shortest_distances[end_vertex]}")
print(f"Shortest path from {start_vertex} to {end_vertex}: {' -> '.join(shortest_paths[end_vertex])}")

# Test case 2: A* search algorithm
start_vertex = "SZR"
end_vertex = "ADS"
print("\nTest case 2: A* search algorithm")
shortest_path = roadmap_graph.a_star(start_vertex, end_vertex)
if shortest_path != "Path is not found":
    print(f"Shortest path from {start_vertex} to {end_vertex}: {' -> '.join(shortest_path)}")
else:
    print(shortest_path)

# Test case 3: Shortest path to a house
house_id = "H1"
destination_vertex = "SMbZR"
print("\nTest case 3: Shortest path to a house")
shortest_distance, shortest_path = roadmap_graph.find_shortest_path_to_house(house_id, destination_vertex)
if isinstance(shortest_distance, str):
    print(shortest_distance)
else:
    print(f"Shortest path from house {house_id} to {destination_vertex}: {' -> '.join(shortest_path)}")
    print(f"Shortest distance: {shortest_distance}")

